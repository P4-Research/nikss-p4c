/* Automatically generated by p4c-ebpf from samples/p4testdata/psa-lpm.p4 on Tue Feb 23 08:21:31 2021
 */
#include "ebpf_kernel.h"

#include <stdbool.h>
#include <linux/if_ether.h>
#include "psa.h"


#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, w, s, v) do { *((u8*)a) = ((*((u8*)a)) & ~(EBPF_MASK(u8, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)

#define bpf_trace_message(fmt, ...)                              \
  ({                                                             \
      char ____fmt[] = fmt;                                      \
      bpf_trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \
  })

struct internal_metadata {
    __u16 pkt_ether_type;
} __attribute__((aligned(4)));

struct ethernet_t {
    u64 dstAddr; /* EthernetAddress */
    u64 srcAddr; /* EthernetAddress */
    u16 etherType; /* bit<16> */
    u8 ebpf_valid;
};
struct ipv4_h {
    u8 version; /* bit<4> */
    u8 ihl; /* bit<4> */
    u8 diffserv; /* bit<8> */
    u16 totalLen; /* bit<16> */
    u16 identification; /* bit<16> */
    u8 flags; /* bit<3> */
    u16 fragOffset; /* bit<13> */
    u8 ttl; /* bit<8> */
    u8 protocol; /* bit<8> */
    u16 hdrChecksum; /* bit<16> */
    u32 srcAddr; /* IPv4Address */
    u32 dstAddr; /* IPv4Address */
    u8 ebpf_valid;
};
struct fwd_metadata_t {
};
struct empty_t {
};
struct metadata {
    struct fwd_metadata_t fwd_metadata; /* fwd_metadata_t */
};
struct headers {
    struct ethernet_t ethernet; /* ethernet_t */
    struct ipv4_h ipv4; /* ipv4_h */
};
struct ingress_tbl_fwd_lpm_key {
    u32	prefixlen;
    u32 field0; /* hdr.ipv4.dstAddr */
};
enum tbl_fwd_0_actions {
    ingress_do_forward,
    ingress_do_drop,
    _NoAction,
};
struct ingress_tbl_fwd_lpm_value {
    enum tbl_fwd_0_actions action;
    union {
        struct {
            u32 egress_port;
        } ingress_do_forward;
        struct {
        } ingress_do_drop;
        struct {
        } _NoAction;
    } u;
};
struct bpf_elf_map SEC("maps") ingress_tbl_fwd_lpm = {
        .type        = BPF_MAP_TYPE_LPM_TRIE,
        .size_key    = sizeof(struct ingress_tbl_fwd_lpm_key),
        .size_value  = sizeof(struct ingress_tbl_fwd_lpm_value),
        .max_elem    = 100,
        .pinning     = 2,
        .flags       = BPF_F_NO_PREALLOC,
};
REGISTER_START()
REGISTER_TABLE(ingress_tbl_fwd_lpm_defaultAction, BPF_MAP_TYPE_ARRAY, sizeof(u32), sizeof(struct ingress_tbl_fwd_lpm_value), 1)
REGISTER_END()

SEC("xdp-ingress")
int xdp_func(struct xdp_md *skb) {
    void *data = (void *)(long)skb->data;
    void *data_end = (void *)(long)skb->data_end;

    struct internal_metadata *meta;
    int ret = bpf_xdp_adjust_meta(skb, -(int)sizeof(*meta));
    if (ret < 0) {
        bpf_printk("[XDP] Error while adjusting meta %d", ret);
        return XDP_ABORTED;
    }
    meta = (struct internal_metadata *)(unsigned long)skb->data_meta;
    data = (void *)(long)skb->data;
    data_end = (void *)(long)skb->data_end;
    if ((void *) ((struct internal_metadata *) meta + 1) > data)
        return XDP_ABORTED;

    struct ethhdr *eth = data;
    if ((void *)((struct ethhdr *) eth + 1) > data_end) {
        return TC_ACT_SHOT;
    }
    meta->pkt_ether_type = eth->h_proto;
    eth->h_proto = bpf_htons(0x0800);

    return XDP_PASS;
}
SEC("tc-ingress")
int tc_ingress_func(SK_BUFF *skb) {
    struct psa_global_metadata *meta = (struct psa_global_metadata *) skb->cb;
    struct headers parsed_hdr = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
    };
    unsigned ebpf_packetOffsetInBits = 0;unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    struct psa_ingress_output_metadata_t ostd = {
            .drop = true,
        };

    bpf_trace_message("tc-ingress parser: parsing new packet\n");
    start: {
        bpf_trace_message("Parser: state start\n");
/* extract(parsed_hdr.ethernet)*/
        bpf_trace_message("Parser: check pkt_len=%%d < last_read_byte=%%d\n", ebpf_packetEnd - pkt, BYTES(ebpf_packetOffsetInBits + 112));
        if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
            bpf_trace_message("Parser: invalid packet (packet too short)\n");
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        bpf_trace_message("Parser: extracting header parsed_hdr.ethernet\n");

        bpf_trace_message("Parser: extracting field dstAddr\n");
        parsed_hdr.ethernet.dstAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
        ebpf_packetOffsetInBits += 48;
        bpf_trace_message("Parser: extracted dstAddr=0x%llx (48 bits)\n", (unsigned long long) parsed_hdr.ethernet.dstAddr);

        bpf_trace_message("Parser: extracting field srcAddr\n");
        parsed_hdr.ethernet.srcAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
        ebpf_packetOffsetInBits += 48;
        bpf_trace_message("Parser: extracted srcAddr=0x%llx (48 bits)\n", (unsigned long long) parsed_hdr.ethernet.srcAddr);

        bpf_trace_message("Parser: extracting field etherType\n");
        parsed_hdr.ethernet.etherType = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;
        bpf_trace_message("Parser: extracted etherType=0x%llx (16 bits)\n", (unsigned long long) parsed_hdr.ethernet.etherType);

        parsed_hdr.ethernet.ebpf_valid = 1;
        bpf_trace_message("Parser: extracted parsed_hdr.ethernet\n");

        switch (parsed_hdr.ethernet.etherType) {
            case 2048: goto ipv4;
            default: goto reject;
        }
    }
    ipv4: {
        bpf_trace_message("Parser: state ipv4\n");
/* extract(parsed_hdr.ipv4)*/
        bpf_trace_message("Parser: check pkt_len=%%d < last_read_byte=%%d\n", ebpf_packetEnd - pkt, BYTES(ebpf_packetOffsetInBits + 160));
        if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
            bpf_trace_message("Parser: invalid packet (packet too short)\n");
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        bpf_trace_message("Parser: extracting header parsed_hdr.ipv4\n");

        bpf_trace_message("Parser: extracting field version\n");
        parsed_hdr.ipv4.version = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
        ebpf_packetOffsetInBits += 4;
        bpf_trace_message("Parser: extracted version=0x%llx (4 bits)\n", (unsigned long long) parsed_hdr.ipv4.version);

        bpf_trace_message("Parser: extracting field ihl\n");
        parsed_hdr.ipv4.ihl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
        ebpf_packetOffsetInBits += 4;
        bpf_trace_message("Parser: extracted ihl=0x%llx (4 bits)\n", (unsigned long long) parsed_hdr.ipv4.ihl);

        bpf_trace_message("Parser: extracting field diffserv\n");
        parsed_hdr.ipv4.diffserv = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 8;
        bpf_trace_message("Parser: extracted diffserv=0x%llx (8 bits)\n", (unsigned long long) parsed_hdr.ipv4.diffserv);

        bpf_trace_message("Parser: extracting field totalLen\n");
        parsed_hdr.ipv4.totalLen = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;
        bpf_trace_message("Parser: extracted totalLen=0x%llx (16 bits)\n", (unsigned long long) parsed_hdr.ipv4.totalLen);

        bpf_trace_message("Parser: extracting field identification\n");
        parsed_hdr.ipv4.identification = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;
        bpf_trace_message("Parser: extracted identification=0x%llx (16 bits)\n", (unsigned long long) parsed_hdr.ipv4.identification);

        bpf_trace_message("Parser: extracting field flags\n");
        parsed_hdr.ipv4.flags = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 5) & EBPF_MASK(u8, 3));
        ebpf_packetOffsetInBits += 3;
        bpf_trace_message("Parser: extracted flags=0x%llx (3 bits)\n", (unsigned long long) parsed_hdr.ipv4.flags);

        bpf_trace_message("Parser: extracting field fragOffset\n");
        parsed_hdr.ipv4.fragOffset = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u16, 13));
        ebpf_packetOffsetInBits += 13;
        bpf_trace_message("Parser: extracted fragOffset=0x%llx (13 bits)\n", (unsigned long long) parsed_hdr.ipv4.fragOffset);

        bpf_trace_message("Parser: extracting field ttl\n");
        parsed_hdr.ipv4.ttl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 8;
        bpf_trace_message("Parser: extracted ttl=0x%llx (8 bits)\n", (unsigned long long) parsed_hdr.ipv4.ttl);

        bpf_trace_message("Parser: extracting field protocol\n");
        parsed_hdr.ipv4.protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 8;
        bpf_trace_message("Parser: extracted protocol=0x%llx (8 bits)\n", (unsigned long long) parsed_hdr.ipv4.protocol);

        bpf_trace_message("Parser: extracting field hdrChecksum\n");
        parsed_hdr.ipv4.hdrChecksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;
        bpf_trace_message("Parser: extracted hdrChecksum=0x%llx (16 bits)\n", (unsigned long long) parsed_hdr.ipv4.hdrChecksum);

        bpf_trace_message("Parser: extracting field srcAddr\n");
        parsed_hdr.ipv4.srcAddr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 32;
        bpf_trace_message("Parser: extracted srcAddr=0x%llx (32 bits)\n", (unsigned long long) parsed_hdr.ipv4.srcAddr);

        bpf_trace_message("Parser: extracting field dstAddr\n");
        parsed_hdr.ipv4.dstAddr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 32;
        bpf_trace_message("Parser: extracted dstAddr=0x%llx (32 bits)\n", (unsigned long long) parsed_hdr.ipv4.dstAddr);

        parsed_hdr.ipv4.ebpf_valid = 1;
        bpf_trace_message("Parser: extracted parsed_hdr.ipv4\n");

        goto accept;
    }

    reject: {
        bpf_trace_message("Parser: packet rejected\n");
        return TC_ACT_SHOT;
    }

    accept:
    {
        struct psa_ingress_input_metadata_t istd = {
            .ingress_port = skb->ifindex,
            .packet_path = meta->packet_path,
            .ingress_timestamp = skb->tstamp,
            .parser_error = NoError,
    };
        bpf_trace_message("tc-ingress control: packet processing started\n");
        u8 hit_1;
        struct psa_ingress_output_metadata_t meta_1;
        {
/* tbl_fwd_0.apply()*/
            {
                /* construct key */
                struct ingress_tbl_fwd_lpm_key key = {};
                key.prefixlen = 32;
                key.field0 = bpf_htonl(parsed_hdr.ipv4.dstAddr);
//                key.field1 = parsed_hdr.ipv4.srcAddr;
                /* value */
                struct ingress_tbl_fwd_lpm_value *value = NULL;
                /* perform lookup */
                value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_fwd_lpm, &key);
                if (value == NULL) {
                    bpf_trace_message("Control: value jest NULL\n");
                    /* miss; find default action */
                    hit_1 = 0;
                    value = BPF_MAP_LOOKUP_ELEM(ingress_tbl_fwd_lpm_defaultAction, &ebpf_zero);
                } else {
                    bpf_trace_message("Control: value jest git\n");
                    hit_1 = 1;
                }
                if (value != NULL) {
                    bpf_trace_message("Control: przechodzenie po akcjach\n");
                    /* run action */
                    switch (value->action) {
                        case ingress_do_forward:
                        {
                            bpf_trace_message("Control: pdo_forward\n");
{
meta_1 = ostd;
                                meta_1.drop = false;
                                meta_1.multicast_group = 0;
                                meta_1.egress_port = value->u.ingress_do_forward.egress_port;
                                ostd = meta_1;
                            }
                        }
                        break;
                        case ingress_do_drop:
                        {
                            bpf_trace_message("Control: do_drop\n");
ostd.drop = true;
                        }
                        break;
                        case _NoAction:
                        {
                            bpf_trace_message("Control: No_action\n");
                        }
                        break;
                        default: return TC_ACT_SHOT;
                    }
                }
                else return TC_ACT_SHOT;
            }
;
        }
    }
    bpf_trace_message("tc-ingress control: packet processing finished\n");
    {
        struct headers hdr = {
            .ethernet = {
                .ebpf_valid = 0
            },
            .ipv4 = {
                .ebpf_valid = 0
            },
        };
        void* hdrVoidPointerVar = (void*)(&hdr);
        int outHeaderLength = 0;
        if (parsed_hdr.ethernet.ebpf_valid) {
            outHeaderLength += 112;
        }
        if (parsed_hdr.ipv4.ebpf_valid) {
            outHeaderLength += 160;
        }

        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(ebpf_packetOffsetInBits);
        int returnCode = 0;
        returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
        if (returnCode) {
            goto reject;
        }
        ebpf_packetOffsetInBits = 0;
        
        if (parsed_hdr.ethernet.ebpf_valid) {
            if (skb->len < BYTES(ebpf_packetOffsetInBits + 112)) {
                goto reject;
            }
            
            parsed_hdr.ethernet.dstAddr = htonll(parsed_hdr.ethernet.dstAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[2];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[3];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[4];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[5];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr.ethernet.srcAddr = htonll(parsed_hdr.ethernet.srcAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[2];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[3];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[4];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[5];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr.ethernet.etherType = bpf_htons(parsed_hdr.ethernet.etherType);
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.etherType))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.etherType))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
        if (parsed_hdr.ipv4.ebpf_valid) {
            if (skb->len < BYTES(ebpf_packetOffsetInBits + 160)) {
                goto reject;
            }
            
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.version))[0];
            write_partial(hdrVoidPointerVar + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr.ipv4.ihl))[0];
            write_partial(hdrVoidPointerVar + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&parsed_hdr.ipv4.diffserv))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr.ipv4.totalLen = bpf_htons(parsed_hdr.ipv4.totalLen);
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.totalLen))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.totalLen))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr.ipv4.identification = bpf_htons(parsed_hdr.ipv4.identification);
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.identification))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.identification))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&parsed_hdr.ipv4.flags))[0];
            write_partial(hdrVoidPointerVar + BYTES(ebpf_packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 3;

            parsed_hdr.ipv4.fragOffset = bpf_htons(parsed_hdr.ipv4.fragOffset << 3);
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.fragOffset))[0];
            write_partial(hdrVoidPointerVar + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
            write_partial(hdrVoidPointerVar + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.fragOffset))[1];
            write_partial(hdrVoidPointerVar + BYTES(ebpf_packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
            ebpf_packetOffsetInBits += 13;

            ebpf_byte = ((char*)(&parsed_hdr.ipv4.ttl))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&parsed_hdr.ipv4.protocol))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            parsed_hdr.ipv4.hdrChecksum = bpf_htons(parsed_hdr.ipv4.hdrChecksum);
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.hdrChecksum))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.hdrChecksum))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            parsed_hdr.ipv4.srcAddr = htonl(parsed_hdr.ipv4.srcAddr);
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.srcAddr))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.srcAddr))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.srcAddr))[2];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.srcAddr))[3];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            parsed_hdr.ipv4.dstAddr = htonl(parsed_hdr.ipv4.dstAddr);
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.dstAddr))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.dstAddr))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.dstAddr))[2];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ipv4.dstAddr))[3];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }

        returnCode = bpf_skb_store_bytes(skb, 0, hdrVoidPointerVar, BYTES(outHeaderLength), 0);
        if (returnCode) {
            goto reject;
        }
    }
    bpf_trace_message("Deparser: wysylamy na port: %d\n", ostd.egress_port);
    return bpf_redirect(ostd.egress_port, 0);
}
SEC("tc-egress")
int tc_egress_func(SK_BUFF *skb) {
    struct psa_global_metadata *meta = (struct psa_global_metadata *) skb->cb;
    struct headers parsed_hdr = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
    };
    unsigned ebpf_packetOffsetInBits = 0;unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    struct psa_ingress_output_metadata_t ostd = {
            .drop = true,
        };

    bpf_trace_message("tc-egress parser: parsing new packet\n");
    start: {
        bpf_trace_message("Parser: state start\n");
/* extract(parsed_hdr.ethernet)*/
        bpf_trace_message("Parser: check pkt_len=%%d < last_read_byte=%%d\n", ebpf_packetEnd - pkt, BYTES(ebpf_packetOffsetInBits + 112));
        if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
            bpf_trace_message("Parser: invalid packet (packet too short)\n");
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        bpf_trace_message("Parser: extracting header parsed_hdr.ethernet\n");

        bpf_trace_message("Parser: extracting field dstAddr\n");
        parsed_hdr.ethernet.dstAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
        ebpf_packetOffsetInBits += 48;
        bpf_trace_message("Parser: extracted dstAddr=0x%llx (48 bits)\n", (unsigned long long) parsed_hdr.ethernet.dstAddr);

        bpf_trace_message("Parser: extracting field srcAddr\n");
        parsed_hdr.ethernet.srcAddr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
        ebpf_packetOffsetInBits += 48;
        bpf_trace_message("Parser: extracted srcAddr=0x%llx (48 bits)\n", (unsigned long long) parsed_hdr.ethernet.srcAddr);

        bpf_trace_message("Parser: extracting field etherType\n");
        parsed_hdr.ethernet.etherType = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;
        bpf_trace_message("Parser: extracted etherType=0x%llx (16 bits)\n", (unsigned long long) parsed_hdr.ethernet.etherType);

        parsed_hdr.ethernet.ebpf_valid = 1;
        bpf_trace_message("Parser: extracted parsed_hdr.ethernet\n");

        goto accept;
    }

    reject: {
        bpf_trace_message("Parser: packet rejected\n");
        return TC_ACT_SHOT;
    }

    accept:
    {
        struct psa_ingress_input_metadata_t istd = {
            .ingress_port = skb->ifindex,
            .packet_path = meta->packet_path,
            .ingress_timestamp = skb->tstamp,
            .parser_error = NoError,
    };
        bpf_trace_message("tc-egress control: packet processing started\n");
        u8 hit_2;
        {
        }
    }
    bpf_trace_message("tc-egress control: packet processing finished\n");
    {
        struct headers hdr = {
            .ethernet = {
                .ebpf_valid = 0
            },
            .ipv4 = {
                .ebpf_valid = 0
            },
        };
        void* hdrVoidPointerVar = (void*)(&hdr);
        int outHeaderLength = 0;
        if (parsed_hdr.ethernet.ebpf_valid) {
            outHeaderLength += 112;
        }

        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(ebpf_packetOffsetInBits);
        int returnCode = 0;
        returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
        if (returnCode) {
            goto reject;
        }
        ebpf_packetOffsetInBits = 0;
        
        if (parsed_hdr.ethernet.ebpf_valid) {
            if (skb->len < BYTES(ebpf_packetOffsetInBits + 112)) {
                goto reject;
            }
            
            parsed_hdr.ethernet.dstAddr = htonll(parsed_hdr.ethernet.dstAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[2];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[3];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[4];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.dstAddr))[5];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr.ethernet.srcAddr = htonll(parsed_hdr.ethernet.srcAddr << 16);
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[2];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[3];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[4];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.srcAddr))[5];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            parsed_hdr.ethernet.etherType = bpf_htons(parsed_hdr.ethernet.etherType);
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.etherType))[0];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&parsed_hdr.ethernet.etherType))[1];
            write_byte(hdrVoidPointerVar, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }

        returnCode = bpf_skb_store_bytes(skb, 0, hdrVoidPointerVar, BYTES(outHeaderLength), 0);
        if (returnCode) {
            goto reject;
        }
    }
    return TC_ACT_OK;
}
char _license[] SEC("license") = "GPL";
