/* Automatically generated by p4c-ebpf from scenarios/basic/p4/vxlan/vxlan.p4 on Wed Jul 28 21:02:21 2021
 */
#include "ebpf_kernel.h"

#include <stdbool.h>
#include <linux/if_ether.h>
#include "psa.h"

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, w, s, v) do { *((u8*)a) = ((*((u8*)a)) & ~(EBPF_MASK(u8, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)
#define bpf_trace_message(fmt, ...)

#define CLONE_MAX_PORTS 64
#define CLONE_MAX_INSTANCES 1
#define CLONE_MAX_CLONES (CLONE_MAX_PORTS * CLONE_MAX_INSTANCES)
#define CLONE_MAX_SESSIONS 1024

#ifndef PSA_PORT_RECIRCULATE
#error "PSA_PORT_RECIRCULATE not specified, please use -DPSA_PORT_RECIRCULATE=n option to specify index of recirculation interface (see the result of command 'ip link')"
#endif
#define P4C_PSA_PORT_RECIRCULATE 0xfffffffa

struct internal_metadata {
    __u16 pkt_ether_type;
} __attribute__((aligned(4)));

struct list_key_t {
    __u32 port;
    __u16 instance;
};
typedef struct list_key_t elem_t;

struct element {
    struct clone_session_entry entry;
    elem_t next_id;
} __attribute__((aligned(4)));


struct empty_metadata_t {
};
struct ethernet_t {
    unsigned char dst_addr[6]; /* ethernet_addr_t */ //przedstawić jako skecwencję u8 części adresu  ?__attribute__((packed));
    unsigned char src_addr[6]; /* ethernet_addr_t */
    u16 ether_type; /* bit<16> */

}__attribute__((packed));
struct ipv4_t {
    u8 ver_ihl; /* bit<8> */
    u8 diffserv; /* bit<8> */
    u16 total_len; /* bit<16> */
    u16 identification; /* bit<16> */
    u16 flags_offset; /* bit<16> */
    u8 ttl; /* bit<8> */
    u8 protocol; /* bit<8> */
    u16 hdr_checksum; /* bit<16> */
    u32 src_addr; /* bit<32> */
    u32 dst_addr; /* bit<32> */


}__attribute__((packed));
struct udp_t {
    u16 src_port; /* bit<16> */
    u16 dst_port; /* bit<16> */
    u16 length; /* bit<16> */
    u16 checksum; /* bit<16> */

}__attribute__((packed));
struct vxlan_t {
    u8 flags; /* bit<8> */
    unsigned char reserved[3]; /* bit<24> */
    unsigned char vni[3]; /* bit<24> */
    u8 reserved2; /* bit<8> */

}__attribute__((packed));
struct headers_t {
    struct ethernet_t *outer_ethernet; /* ethernet_t */
    struct ipv4_t *outer_ipv4; /* ipv4_t */
    struct udp_t *outer_udp; /* udp_t */
    struct ethernet_t *ethernet; /* ethernet_t */
    struct ipv4_t *ipv4; /* ipv4_t */
    struct vxlan_t *vxlan; /* vxlan_t */
};

struct ebpf_valid_flags_t {
    u8 ethernet_valid;
    u8 ipv4_valid;
    u8 vxlan_valid;
    u8 outer_ethernet_valid;
    u8 outer_ipv4_valid;
    u8 outer_udp_valid;
};
struct offsets_t {
    u8 ethernet_offset;
    u8 ipv4_offset;
    u8 vxlan_offset;
    u8 outer_ethernet_offset;
    u8 outer_ipv4_offset;
    u8 outer_udp_offset;
};

struct tmp_headers_t {
    int  a[50];
};
struct local_metadata_t {
};

struct ingress_vxlan_key {
    unsigned char field0[8]; /* headers.ethernet.dst_addr */
} __attribute__((aligned(4)));
#define INGRESS_VXLAN_ACT_INGRESS_VXLAN_ENCAP 1
#define INGRESS_VXLAN_ACT_INGRESS_VXLAN_DECAP 2
struct ingress_vxlan_value {
    unsigned int action;
    union {
        struct {
        } _NoAction;
        struct {
            unsigned char ethernet_dst_addr[6];
            unsigned char ethernet_src_addr[6];
            u32 ipv4_src_addr;
            u32 ipv4_dst_addr;
            unsigned char vxlan_vni[3];
            u32 port_out;
        } ingress_vxlan_encap;
        struct {
            u32 port_out;
        } ingress_vxlan_decap;
    } u;
};
REGISTER_START()
REGISTER_TABLE_INNER(clone_session_tbl_inner, BPF_MAP_TYPE_HASH, sizeof(elem_t), sizeof(struct element), 64, 1, 1)
BPF_ANNOTATE_KV_PAIR(clone_session_tbl_inner, elem_t, struct element)
REGISTER_TABLE_OUTER(clone_session_tbl, BPF_MAP_TYPE_ARRAY_OF_MAPS, sizeof(__u32), sizeof(__u32), 1024, 1, clone_session_tbl_inner)
BPF_ANNOTATE_KV_PAIR(clone_session_tbl, __u32, __u32)
REGISTER_TABLE_INNER(multicast_grp_tbl_inner, BPF_MAP_TYPE_HASH, sizeof(elem_t), sizeof(struct element), 64, 2, 2)
BPF_ANNOTATE_KV_PAIR(multicast_grp_tbl_inner, elem_t, struct element)
REGISTER_TABLE_OUTER(multicast_grp_tbl, BPF_MAP_TYPE_ARRAY_OF_MAPS, sizeof(__u32), sizeof(__u32), 1024, 2, multicast_grp_tbl_inner)
BPF_ANNOTATE_KV_PAIR(multicast_grp_tbl, __u32, __u32)
REGISTER_TABLE(ingress_vxlan, BPF_MAP_TYPE_HASH, sizeof(struct ingress_vxlan_key), sizeof(struct ingress_vxlan_value), 1048576)
BPF_ANNOTATE_KV_PAIR(ingress_vxlan, struct ingress_vxlan_key, struct ingress_vxlan_value)
REGISTER_TABLE(ingress_vxlan_defaultAction, BPF_MAP_TYPE_ARRAY, sizeof(u32), sizeof(struct ingress_vxlan_value), 1)
BPF_ANNOTATE_KV_PAIR(ingress_vxlan_defaultAction, u32, struct ingress_vxlan_value)
REGISTER_END()

SEC("classifier/map-initializer")
int map_initializer() {
    u32 ebpf_zero = 0;

    return 0;
}

SEC("xdp/xdp-ingress")
int xdp_func(struct xdp_md *skb) {
    void *data = (void *)(long)skb->data;
    void *data_end = (void *)(long)skb->data_end;

    struct internal_metadata *meta;
    int ret = bpf_xdp_adjust_meta(skb, -(int)sizeof(*meta));
    if (ret < 0) {
        return XDP_ABORTED;
    }
    meta = (struct internal_metadata *)(unsigned long)skb->data_meta;
    data = (void *)(long)skb->data;
    data_end = (void *)(long)skb->data_end;
    if ((void *) ((struct internal_metadata *) meta + 1) > data)
        return XDP_ABORTED;

    struct ethhdr *eth = data;
    if ((void *)((struct ethhdr *) eth + 1) > data_end) {
        return XDP_ABORTED;
    }
    meta->pkt_ether_type = eth->h_proto;
    eth->h_proto = bpf_htons(0x0800);

    return XDP_PASS;
}
static __always_inline
void crc16_update(u16 * reg, const u8 * data, u16 data_size, const u16 poly) {
    data += data_size - 1;
    for (u16 i = 0; i < data_size; i++) {
        bpf_trace_message("CRC16: data byte: %x\n", *data);
        *reg ^= *data;
        for (u8 bit = 0; bit < 8; bit++) {
            *reg = (*reg) & 1 ? ((*reg) >> 1) ^ poly : (*reg) >> 1;
        }
        data--;
    }
}
static __always_inline u16 crc16_finalize(u16 reg, const u16 poly) {
return reg;
}
static __always_inline
void crc32_update(u32 * reg, const u8 * data, u16 data_size, const u32 poly) {
    data += data_size - 1;
    for (u16 i = 0; i < data_size; i++) {
        bpf_trace_message("CRC32: data byte: %x\n", *data);
        *reg ^= *data;
        for (u8 bit = 0; bit < 8; bit++) {
            *reg = (*reg) & 1 ? ((*reg) >> 1) ^ poly : (*reg) >> 1;
        }
        data--;
    }
}
static __always_inline u32 crc32_finalize(u32 reg, const u32 poly) {
return reg ^ 0xFFFFFFFF;
}
inline u16 csum16_add(u16 csum, u16 addend) {
u16 res = csum;
res += addend;
return (res + (res < addend));
}
inline u16 csum16_sub(u16 csum, u16 addend) {
return csum16_add(csum, ~addend);
}
static __always_inline
int do_for_each(SK_BUFF *skb, void *map, unsigned int max_iter, void (*a)(SK_BUFF *, void *))
{
    elem_t head_idx = {0, 0};
    struct element *elem = bpf_map_lookup_elem(map, &head_idx);
    if (!elem) {
        return -1;
    }
    if (elem->next_id.port == 0 && elem->next_id.instance == 0) {
        return 0;
    }
    elem_t next_id = elem->next_id;
    for (unsigned int i = 0; i < max_iter; i++) {
        struct element *elem = bpf_map_lookup_elem(map, &next_id);
        if (!elem) {
            break;
        }
        a(skb, &elem->entry);
        if (elem->next_id.port == 0 && elem->next_id.instance == 0) {
            break;
        }
        next_id = elem->next_id;
    }
    return 0;
}

static __always_inline
void do_clone(SK_BUFF *skb, void *data)
{
    struct clone_session_entry *entry = (struct clone_session_entry *) data;
    bpf_clone_redirect(skb, entry->egress_port, 0);
}

static __always_inline
int do_packet_clones(SK_BUFF * skb, void * map, __u32 session_id, PSA_PacketPath_t new_pkt_path, __u8 caller_id)
{
    struct psa_global_metadata * meta = (struct psa_global_metadata *) skb->cb;
    void * inner_map;
    inner_map = bpf_map_lookup_elem(map, &session_id);
    if (inner_map != NULL) {
        PSA_PacketPath_t original_pkt_path = meta->packet_path;
        meta->packet_path = new_pkt_path;
        if (do_for_each(skb, inner_map, CLONE_MAX_CLONES, &do_clone) < 0) {
            return -1;
        }
        meta->packet_path = original_pkt_path;
    } else {
    }
    return 0;
}

static __always_inline int process(SK_BUFF *skb, struct headers_t *headers, struct psa_ingress_output_metadata_t *ostd, struct empty_metadata_t *resubmit_meta)
{
    struct psa_global_metadata *meta = (struct psa_global_metadata *) skb->cb;
    if (meta->packet_path == NORMAL) {
        struct internal_metadata *md = (struct internal_metadata *)(unsigned long)skb->data_meta;
        if ((void *) ((struct internal_metadata *) md + 1) > (void *)(long)skb->data) {
            return TC_ACT_SHOT;
        }
        __u16 *ether_type = (__u16 *) ((void *) (long)skb->data + 12);
        if ((void *) ((__u16 *) ether_type + 1) >     (void *) (long) skb->data_end) {
            return TC_ACT_SHOT;
        }
        *ether_type = md->pkt_ether_type;
    }
    struct local_metadata_t local_metadata1 = {
    };
    unsigned ebpf_packetOffsetInBits = 0;unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;
    u64 tstamp = skb->tstamp;
    struct ebpf_valid_flags_t validFlags = {
        .ethernet_valid = 0,
        .ipv4_valid = 0,
        .vxlan_valid = 0,
        .outer_ethernet_valid = 0,
        .outer_ipv4_valid = 0,
        .outer_udp_valid = 0
    };
    struct offsets_t offsets = {
        .ethernet_offset = 0,
        .ipv4_offset = 0,
        .vxlan_offset = 0,
        .outer_ethernet_offset = 0,
        .outer_ipv4_offset = 0,
        .outer_udp_offset = 0
    };
    struct tmp_headers_t tmp_header = {};
    char * ptr = (char *)(&tmp_header);
    // sprawdzenie czy offset in bits jest większe niż packet end
    if (ebpf_packetEnd < pkt + 20) {

        return TC_ACT_SHOT;
    };

    //bpf_skb_load_bytes(skb, 0, ptr, 100/*BYTES(ebpf_packetOffsetInBits)*/); //
    __builtin_memcpy(ptr, skb->data, /*BYTES(ebpf_packetOffsetInBits)*/20);

    volatile struct headers_t pkt_copy = {};
    struct ethernet_t outerEthernet = {};
    pkt_copy.outer_ethernet = &outerEthernet;
    struct ipv4_t outerIP = {};
    pkt_copy.outer_ipv4 = &outerIP;
    struct udp_t outerUDP = {};
    pkt_copy.outer_udp = &outerUDP;
    struct vxlan_t outerVXLAN = {};
    pkt_copy.outer_ethernet = &outerEthernet;
    struct ethernet_t Ethernet = {};
    pkt_copy.ethernet = &Ethernet;
    struct ipv4_t IP = {};
    pkt_copy.ipv4 = &IP;

    /*if (validFlags.outer_ethernet_valid) {
        pkt_copy.outer_ethernet = (struct ethernet_t *)(ptr + offsets.outer_ethernet_offset);
    };
    if (validFlags.outer_ipv4_valid) {
        pkt_copy.outer_ipv4 = (struct ipv4_t *)(ptr + offsets.outer_ipv4_offset);
    };
    if (validFlags.outer_udp_valid) {
        pkt_copy.outer_udp = (struct udp_t *)(ptr  + offsets.outer_udp_offset);
    };
    if (validFlags.vxlan_valid) {
        pkt_copy.vxlan = (struct vxlan_t *)(ptr  + offsets.vxlan_offset);
    };
    if (validFlags.ethernet_valid) {
        pkt_copy.ethernet = (struct ethernet_t *)(ptr  + offsets.ethernet_offset);
    };
    if (validFlags.ipv4_valid) {
        pkt_copy.ipv4 = (struct ipv4_t *)(ptr  + offsets.ipv4_offset);
    };*/
start: {
/* extract(headers->ethernet)*/
    /*if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
        ebpf_errorCode = PacketTooShort;
        goto reject;
    }*/
    pkt_copy.ethernet = (struct ethernet_t *)(ptr + BYTES(ebpf_packetOffsetInBits)); ///////// ?? co z bitami? przez to błąd przy deprasowaniu ipv4 outer?
    //headers->ethernet.dst_addr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
    ebpf_packetOffsetInBits += 48;

    //headers->ethernet.src_addr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
    ebpf_packetOffsetInBits += 48;

    //headers->ethernet.ether_type = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    validFlags.ethernet_valid = 1;

/* extract(headers->ipv4)*/
    /*if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
        ebpf_errorCode = PacketTooShort;
        goto reject;
    }*/
    pkt_copy.ipv4 = (struct ipv4_t *)(ptr + BYTES(ebpf_packetOffsetInBits));
    offsets.outer_ipv4_offset = BYTES(ebpf_packetOffsetInBits);
    //headers->ipv4.ver_ihl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.diffserv = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.total_len = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.identification = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.flags_offset = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.ttl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.hdr_checksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.src_addr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 32;

    //headers->ipv4.dst_addr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 32;

    validFlags.outer_ipv4_valid = 1;

    switch (pkt_copy.ipv4->protocol) {
        case 17: goto parse_udp;
        default: goto accept;
    }
}
    parse_udp: {
/* extract(headers->outer_udp)*/
    /*if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
        ebpf_errorCode = PacketTooShort;
        goto reject;
    }*/
    pkt_copy.outer_udp = (struct udp_t *)(ptr + BYTES(ebpf_packetOffsetInBits));
    offsets.outer_udp_offset = BYTES(ebpf_packetOffsetInBits);
    //headers->outer_udp.src_port = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->outer_udp.dst_port = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->outer_udp.length = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->outer_udp.checksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    validFlags.outer_udp_valid = 1;

    switch (pkt_copy.outer_udp->dst_port) {
        case 4789: goto parse_vxlan;
        default: goto accept;
    }
}
    parse_vxlan: {
/* extract(headers->vxlan)*/
    /*if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
        ebpf_errorCode = PacketTooShort;
        goto reject;
    }*/
    pkt_copy.vxlan = (struct vxlan_t *)(ptr + BYTES(ebpf_packetOffsetInBits));
    offsets.vxlan_offset = BYTES(ebpf_packetOffsetInBits);
    //headers->vxlan.flags = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->vxlan.reserved = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 8) & EBPF_MASK(u32, 24));
    ebpf_packetOffsetInBits += 24;

    //headers->vxlan.vni = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 8) & EBPF_MASK(u32, 24));
    ebpf_packetOffsetInBits += 24;

    //headers->vxlan.reserved2 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    validFlags.vxlan_valid = 1;

    struct ethernet_t outerEthernet = {};
    pkt_copy.outer_ethernet = &outerEthernet;
    __builtin_memcpy(pkt_copy.outer_ethernet, pkt_copy.ethernet, sizeof(outerEthernet)); // ENKAPSULACJA

    //headers->outer_ethernet = *headers->ethernet;/* extract(headers->ethernet)*/
    /*if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
        ebpf_errorCode = PacketTooShort;
        goto reject;
    }*/
    pkt_copy.ethernet = (struct ethernet_t *)(ptr + BYTES(ebpf_packetOffsetInBits));
    offsets.ethernet_offset = BYTES(ebpf_packetOffsetInBits);
    //headers->ethernet.dst_addr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
    ebpf_packetOffsetInBits += 48;

    //headers->ethernet.src_addr = (u64)((load_dword(pkt, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
    ebpf_packetOffsetInBits += 48;

    //headers->ethernet.ether_type = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    validFlags.ethernet_valid = 1;

    switch (pkt_copy.ethernet->ether_type) {
        case 2048: goto parse_inner_ipv4;
        default: goto accept;
    }
}
    parse_inner_ipv4: {
    struct ipv4_t outerIpv4 = {};
    pkt_copy.outer_ipv4 = &outerIpv4;
    __builtin_memcpy(pkt_copy.outer_ipv4, pkt_copy.ipv4, sizeof(outerIpv4)); // ENKAPSULACJA
    //*headers->outer_ipv4 = *headers->ipv4;/* extract(headers->ipv4)*/
    /*if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
        ebpf_errorCode = PacketTooShort;
        goto reject;
    }*/
    pkt_copy.ipv4 = (struct ipv4_t *)(ptr + BYTES(ebpf_packetOffsetInBits));
    offsets.ipv4_offset = BYTES(ebpf_packetOffsetInBits);
    //headers->ipv4.ver_ihl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.diffserv = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.total_len = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.identification = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //->ipv4.flags_offset = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.ttl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 8;

    //headers->ipv4.hdr_checksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 16;

    //headers->ipv4.src_addr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 32;

    //headers->ipv4.dst_addr = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
    ebpf_packetOffsetInBits += 32;

    validFlags.ipv4_valid = 1;

    goto accept;
}

    reject: {
    if (ebpf_errorCode == 0) {
        return TC_ACT_SHOT;
    }
    goto accept;
}

    accept:
    {
        struct psa_ingress_input_metadata_t standard_metadata = {
                .ingress_port = skb->ifindex,
                .packet_path = meta->packet_path,
                .ingress_timestamp = skb->tstamp,
                .parser_error = ebpf_errorCode,
        };
        u8 hit_1;
        {
            if (            validFlags.vxlan_valid) {
                if (ebpf_packetEnd < ptr + offsets.ethernet_offset+6) { // sprawdzenie pozwala przypisac to co poniżej; jak zrobić to sprawdzenie optymalnie?
                    return TC_ACT_SHOT;
                };
                struct ethernet_t tmp_eth ={};
                pkt_copy.ethernet = &tmp_eth;
                /*headers->ethernet->dst_addr[0] = headers->outer_ethernet->dst_addr[0];
                headers->ethernet->dst_addr[1] = headers->outer_ethernet->dst_addr[1];
                headers->ethernet->dst_addr[2] = headers->outer_ethernet->dst_addr[2];
                headers->ethernet->dst_addr[3] = headers->outer_ethernet->dst_addr[3];
                headers->ethernet->dst_addr[4] = headers->outer_ethernet->dst_addr[4];
                headers->ethernet->dst_addr[5] = headers->outer_ethernet->dst_addr[5];*/

                __builtin_memcpy(pkt_copy.ethernet->dst_addr, pkt_copy.outer_ethernet->dst_addr, sizeof(pkt_copy.outer_ethernet->dst_addr));

            } // enkapsulacja

            {
                /* construct key */
                struct ingress_vxlan_key key = {};

                /*key.field0[0] = headers->ethernet->dst_addr[0]; // czy to ok przy lookupie? Dlaczego ethernet a nie outer_ethernet
                key.field0[1] = headers->ethernet->dst_addr[1];
                key.field0[2] = headers->ethernet->dst_addr[2];
                key.field0[3] = headers->ethernet->dst_addr[3];
                key.field0[4] = headers->ethernet->dst_addr[4];
                key.field0[5] = headers->ethernet->dst_addr[5];*/
                if (headers->ethernet) {
                    __builtin_memcpy(key.field0, pkt_copy.ethernet->dst_addr, sizeof(pkt_copy.ethernet->dst_addr));
                };

                /* value */
                struct ingress_vxlan_value *value = NULL;
                /* perform lookup */
                value = BPF_MAP_LOOKUP_ELEM(ingress_vxlan, &key);
                if (value == NULL) {
                    /* miss; find default action */
                    hit_1 = 0;
                    value = BPF_MAP_LOOKUP_ELEM(ingress_vxlan_defaultAction, &ebpf_zero);
                } else {
                    hit_1 = 1;
                }
                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case INGRESS_VXLAN_ACT_INGRESS_VXLAN_ENCAP:
                        {

                            //headers->outer_ethernet.ebpf_valid = true;
                            validFlags.outer_ethernet_valid = 1;
                            struct ethernet_t outerEthernet_2 = {};
                            pkt_copy.outer_ethernet = &outerEthernet_2;
                            __builtin_memcpy(pkt_copy.outer_ethernet->src_addr, &(value->u.ingress_vxlan_encap.ethernet_src_addr),sizeof(pkt_copy.outer_ethernet->src_addr));
                            __builtin_memcpy(pkt_copy.outer_ethernet->dst_addr, &(value->u.ingress_vxlan_encap.ethernet_dst_addr), sizeof(pkt_copy.outer_ethernet->dst_addr));
                            /*headers->outer_ethernet->src_addr[0] = value->u.ingress_vxlan_encap.ethernet_src_addr[0];
                            headers->outer_ethernet->src_addr[1] = value->u.ingress_vxlan_encap.ethernet_src_addr[1];
                            headers->outer_ethernet->src_addr[2] = value->u.ingress_vxlan_encap.ethernet_src_addr[2];
                            headers->outer_ethernet->src_addr[3] = value->u.ingress_vxlan_encap.ethernet_src_addr[3];
                            headers->outer_ethernet->src_addr[4] = value->u.ingress_vxlan_encap.ethernet_src_addr[4];
                            headers->outer_ethernet->src_addr[5] = value->u.ingress_vxlan_encap.ethernet_src_addr[5];
                            headers->outer_ethernet->dst_addr[0] = value->u.ingress_vxlan_encap.ethernet_dst_addr[0];
                            headers->outer_ethernet->dst_addr[1] = value->u.ingress_vxlan_encap.ethernet_dst_addr[1];
                            headers->outer_ethernet->dst_addr[2] = value->u.ingress_vxlan_encap.ethernet_dst_addr[2];
                            headers->outer_ethernet->dst_addr[3] = value->u.ingress_vxlan_encap.ethernet_dst_addr[3];
                            headers->outer_ethernet->dst_addr[4] = value->u.ingress_vxlan_encap.ethernet_dst_addr[4];
                            headers->outer_ethernet->dst_addr[5] = value->u.ingress_vxlan_encap.ethernet_dst_addr[5];*/
                            pkt_copy.outer_ethernet->ether_type = 2048;
                            //headers->outer_ipv4.ebpf_valid = true;
                            validFlags.outer_ipv4_valid = 1;
                            struct ipv4_t outerIpv4_2 = {};
                            pkt_copy.outer_ipv4 = &outerIpv4_2;
                            pkt_copy.outer_ipv4->ver_ihl = 69;
                            pkt_copy.outer_ipv4->diffserv = 0;

                            pkt_copy.outer_ipv4->total_len = pkt_copy.ipv4->total_len + 50;


                            pkt_copy.outer_ipv4->identification = 5395;
                            pkt_copy.outer_ipv4->flags_offset = 0;
                            pkt_copy.outer_ipv4->ttl = 64;
                            pkt_copy.outer_ipv4->protocol = 17;
                            pkt_copy.outer_ipv4->src_addr = value->u.ingress_vxlan_encap.ipv4_src_addr;
                            pkt_copy.outer_ipv4->dst_addr = value->u.ingress_vxlan_encap.ipv4_dst_addr;
                            //headers->outer_udp.ebpf_valid = true;
                            validFlags.outer_udp_valid = 1;
                            struct udp_t tmp_udp ={};
                            pkt_copy.outer_udp = &tmp_udp;
                            pkt_copy.outer_udp->src_port = 15221;
                            pkt_copy.outer_udp->dst_port = 4789;

                            pkt_copy.outer_udp->length = pkt_copy.ipv4->total_len + 30;

                            //headers->vxlan.ebpf_valid = true;
                            validFlags.vxlan_valid = 1;
                            struct vxlan_t tmp_vxlan ={};
                            pkt_copy.vxlan = &tmp_vxlan;
                            pkt_copy.vxlan->flags = 0;
                                // tak samo jak dla ethernet... można to załatwić memcpy?
                            pkt_copy.vxlan->reserved[0] = 0;
                            pkt_copy.vxlan->reserved[1] = 0;
                            pkt_copy.vxlan->reserved[2] = 0;
                            /*headers->vxlan->vni[0] = value->u.ingress_vxlan_encap.vxlan_vni[0];
                            headers->vxlan->vni[1] = value->u.ingress_vxlan_encap.vxlan_vni[1];
                            headers->vxlan->vni[2] = value->u.ingress_vxlan_encap.vxlan_vni[2];*/



                            __builtin_memcpy(pkt_copy.vxlan->vni, &(value->u.ingress_vxlan_encap.vxlan_vni), sizeof(pkt_copy.vxlan->vni));
                            pkt_copy.vxlan->reserved2 = 0;
                            ostd->drop = false;
                            ostd->egress_port = value->u.ingress_vxlan_encap.port_out;
                        }
                            break;
                        case INGRESS_VXLAN_ACT_INGRESS_VXLAN_DECAP:
                        {
                            /*headers->outer_ethernet.ebpf_valid = false;
                            headers->outer_ipv4.ebpf_valid = false;
                            headers->outer_udp.ebpf_valid = false;
                            headers->vxlan.ebpf_valid = false;*/
                            validFlags.outer_ethernet_valid = 0;
                            validFlags.outer_ipv4_valid = 0;
                            validFlags.outer_udp_valid = 0;
                            validFlags.vxlan_valid = 0;
                            ostd->drop = false;
                            ostd->egress_port = value->u.ingress_vxlan_decap.port_out;
                        }
                            break;
                        case 0:
                        {

                            /*ostd->drop = false;

                            if (skb->ifindex == (u32) 8) {
                                ostd->egress_port = (u32) 11;
                            }
                            else if (skb->ifindex == (u32) 11) {
                                ostd->egress_port = (u32) 8;
                            }*/
                        }
                            break;
                        default:
                            return TC_ACT_SHOT;
                    }
                } else {
                    return TC_ACT_SHOT;
                }
            }
            ;
        }
    }
    {
        {
            ;
            ;
            ;
            ;
            ;
            ;
        }
// ########################### KOPIA ##########################




        if (ostd->clone) {
            do_packet_clones(skb, &clone_session_tbl, ostd->clone_session_id, CLONE_I2E, 1);
        }
        if (ostd->drop) {
            return TC_ACT_SHOT;
        }
        if (ostd->resubmit) {
            meta->packet_path = RESUBMIT;
            return TC_ACT_UNSPEC;
        }
        int outHeaderLength = 0;
        if (validFlags.outer_ethernet_valid) {
            outHeaderLength += 112;
        }
        if (validFlags.outer_ipv4_valid) {
            outHeaderLength += 160;
        }
        if (validFlags.outer_udp_valid) {
            outHeaderLength += 64;
        }
        if (validFlags.vxlan_valid) {
            outHeaderLength += 64;
        }
        if (validFlags.ethernet_valid) {
            outHeaderLength += 112;
        }
        if (validFlags.ipv4_valid) {
            outHeaderLength += 160;
        }

        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(ebpf_packetOffsetInBits);
        if (outHeaderOffset != 0) {
            int returnCode = 0;
            returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
            if (returnCode) {
                return TC_ACT_SHOT;
            }
        }
        pkt = ((void*)(long)skb->data);
        ebpf_packetEnd = ((void*)(long)skb->data_end);
        ebpf_packetOffsetInBits = 0;
        if (validFlags.outer_ethernet_valid ) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
                return TC_ACT_SHOT;
            }
            //pkt_copy.outer_ethernet->dst_addr[0] = htons(pkt_copy.outer_ethernet->dst_addr[5] /*<< 16*/);

            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->dst_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->dst_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->dst_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->dst_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->dst_addr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->dst_addr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            /*headers->outer_ethernet->dst_addr = htonll(headers->outer_ethernet->dst_addr << 16);
            ebpf_byte = ((char*)(&headers->outer_ethernet.dst_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&headers->outer_ethernet.dst_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&headers->outer_ethernet.dst_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&headers->outer_ethernet.dst_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&headers->outer_ethernet.dst_addr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&headers->outer_ethernet.dst_addr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));*/
            ebpf_packetOffsetInBits += 48;

            //pkt_copy.outer_ethernet->src_addr = htonll(pkt_copy.outer_ethernet->src_addr /*<< 16*/);

            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->src_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->src_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->src_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->src_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->src_addr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->src_addr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            pkt_copy.outer_ethernet->ether_type = bpf_htons(pkt_copy.outer_ethernet->ether_type);
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->ether_type))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ethernet->ether_type))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
        if (validFlags.outer_ipv4_valid) {


            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
                return TC_ACT_SHOT;
            };



            ebpf_byte = ((char*)(&(pkt_copy.outer_ipv4->ver_ihl)))[0]; //failed; padding? bez [0] przechodzi
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->diffserv))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            pkt_copy.outer_ipv4->total_len = bpf_htons(pkt_copy.outer_ipv4->total_len);
            ebpf_byte = ((char*)(&(pkt_copy.outer_ipv4->total_len)))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&(pkt_copy.outer_ipv4->total_len)))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.outer_ipv4->identification = bpf_htons(pkt_copy.outer_ipv4->identification);
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->identification))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->identification))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.outer_ipv4->flags_offset = bpf_htons(pkt_copy.outer_ipv4->flags_offset);
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->flags_offset))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->flags_offset))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->ttl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->protocol))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            pkt_copy.outer_ipv4->hdr_checksum = bpf_htons(pkt_copy.outer_ipv4->hdr_checksum);
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->hdr_checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->hdr_checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.outer_ipv4->src_addr = htonl(pkt_copy.outer_ipv4->src_addr);
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->src_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->src_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->src_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->src_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            pkt_copy.outer_ipv4->dst_addr = htonl(pkt_copy.outer_ipv4->dst_addr);
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->dst_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->dst_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->dst_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_ipv4->dst_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
        if (validFlags.outer_udp_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }

            pkt_copy.outer_udp->src_port = bpf_htons(pkt_copy.outer_udp->src_port);
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->src_port))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->src_port))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.outer_udp->dst_port = bpf_htons(pkt_copy.outer_udp->dst_port);
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->dst_port))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->dst_port))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.outer_udp->length = bpf_htons(pkt_copy.outer_udp->length);
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->length))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->length))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.outer_udp->checksum = bpf_htons(pkt_copy.outer_udp->checksum);
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.outer_udp->checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
        if (validFlags.vxlan_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }

            ebpf_byte = ((char*)(&pkt_copy.vxlan->flags))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            //pkt_copy.vxlan->reserved = htonl(pkt_copy.vxlan->reserved << 8);
            ebpf_byte = ((char*)(&pkt_copy.vxlan->reserved))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.vxlan->reserved))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.vxlan->reserved))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

            //pkt_copy.vxlan->vni = htonl(pkt_copy.vxlan->vni << 8);
            ebpf_byte = ((char*)(&pkt_copy.vxlan->vni))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.vxlan->vni))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.vxlan->vni))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

            ebpf_byte = ((char*)(&pkt_copy.vxlan->reserved2))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

        }
        if (validFlags.ethernet_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
                return TC_ACT_SHOT;
            }

            //pkt_copy.ethernet->dst_addr = htonll(pkt_copy.ethernet->dst_addr /*<< 16*/);

            ebpf_byte = ((char*)(&pkt_copy.ethernet->dst_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->dst_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->dst_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->dst_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->dst_addr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->dst_addr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            //pkt_copy.ethernet->src_addr = htonll(pkt_copy.ethernet->src_addr /*<< 16*/);
            ebpf_byte = ((char*)(&pkt_copy.ethernet->src_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->src_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->src_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->src_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->src_addr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->src_addr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            pkt_copy.ethernet->ether_type = bpf_htons(pkt_copy.ethernet->ether_type);
            ebpf_byte = ((char*)(&pkt_copy.ethernet->ether_type))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ethernet->ether_type))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
        if (validFlags.ipv4_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
                return TC_ACT_SHOT;
            }

            ebpf_byte = ((char*)(&pkt_copy.ipv4->ver_ihl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&pkt_copy.ipv4->diffserv))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            pkt_copy.ipv4->total_len = bpf_htons(pkt_copy.ipv4->total_len);
            ebpf_byte = ((char*)(&pkt_copy.ipv4->total_len))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->total_len))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.ipv4->identification = bpf_htons(pkt_copy.ipv4->identification);
            ebpf_byte = ((char*)(&pkt_copy.ipv4->identification))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->identification))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.ipv4->flags_offset = bpf_htons(pkt_copy.ipv4->flags_offset);
            ebpf_byte = ((char*)(&pkt_copy.ipv4->flags_offset))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->flags_offset))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&pkt_copy.ipv4->ttl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&pkt_copy.ipv4->protocol))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            pkt_copy.ipv4->hdr_checksum = bpf_htons(pkt_copy.ipv4->hdr_checksum);
            ebpf_byte = ((char*)(&pkt_copy.ipv4->hdr_checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->hdr_checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            pkt_copy.ipv4->src_addr = htonl(pkt_copy.ipv4->src_addr);
            ebpf_byte = ((char*)(&pkt_copy.ipv4->src_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->src_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->src_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->src_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            pkt_copy.ipv4->dst_addr = htonl(pkt_copy.ipv4->dst_addr);
            ebpf_byte = ((char*)(&pkt_copy.ipv4->dst_addr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->dst_addr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->dst_addr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&pkt_copy.ipv4->dst_addr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }

    }
    return TC_ACT_UNSPEC;
}
SEC("classifier/tc-ingress")
int tc_ingress_func(SK_BUFF *skb) {
    struct psa_ingress_output_metadata_t ostd = {
            .drop = true,
    };

    struct empty_metadata_t resubmit_meta;
    volatile struct headers_t headers = {};/*= {
            .ethernet = {
                    .ebpf_valid = 0
            },
            .ipv4 = {
                    .ebpf_valid = 0
            },
            .vxlan = {
                    .ebpf_valid = 0
            },
            .outer_ethernet = {
                    .ebpf_valid = 0
            },
            .outer_ipv4 = {
                    .ebpf_valid = 0
            },
            .outer_udp = {
                    .ebpf_valid = 0
            },
    };*/

    int ret = TC_ACT_UNSPEC;
#pragma clang loop unroll(disable)
    for (int i = 0; i < 4; i++) {
        ostd.resubmit = 0;
        ret = process(skb, (struct headers_t *) &headers, &ostd, &resubmit_meta);
        if (ostd.drop == 1 || ostd.resubmit == 0) {
            break;
        }
        __builtin_memset((void *) &headers, 0, sizeof(struct headers_t));
    }
    if (ret != TC_ACT_UNSPEC) {
        return ret;
    }
    if (ostd.multicast_group != 0) {
        do_packet_clones(skb, &multicast_grp_tbl, ostd.multicast_group, NORMAL_MULTICAST, 2);
        return TC_ACT_SHOT;
    }
    skb->priority = ostd.class_of_service;
    return bpf_redirect(ostd.egress_port, 0);
}
SEC("classifier/tc-egress")
int tc_egress_func(SK_BUFF *skb) {
    struct psa_global_metadata *meta = (struct psa_global_metadata *) skb->cb;
    volatile struct headers_t headers ={}; /*= {
            .ethernet = {
                    .ebpf_valid = 0
            },
            .ipv4 = {
                    .ebpf_valid = 0
            },
            .vxlan = {
                    .ebpf_valid = 0
            },
            .outer_ethernet = {
                    .ebpf_valid = 0
            },
            .outer_ipv4 = {
                    .ebpf_valid = 0
            },
            .outer_udp = {
                    .ebpf_valid = 0
            },
    };*/
    unsigned ebpf_packetOffsetInBits = 0;unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;
    u64 tstamp = skb->tstamp;
    struct psa_egress_input_metadata_t istd = {
            .class_of_service = skb->priority,
            .egress_port = skb->ifindex,
            .packet_path = meta->packet_path,
            .instance = meta->instance,
            .egress_timestamp = skb->tstamp,
            .parser_error = ebpf_errorCode,
    };
    if (istd.egress_port == PSA_PORT_RECIRCULATE) {
        istd.egress_port = P4C_PSA_PORT_RECIRCULATE;
    }
    struct psa_egress_output_metadata_t ostd = {
            .clone = false,
            .drop = false,
    };

    start: {
    goto accept;
}

    reject: {
    if (ebpf_errorCode == 0) {
        return TC_ACT_SHOT;
    }
    goto accept;
}

    accept:
    istd.parser_error = ebpf_errorCode;
    {
        u8 hit_2;
        {
        }
    }
    {
        {
        }
        int outHeaderLength = 0;

        int outHeaderOffset = BYTES(outHeaderLength) - BYTES(ebpf_packetOffsetInBits);
        if (outHeaderOffset != 0) {
            int returnCode = 0;
            returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
            if (returnCode) {
                return TC_ACT_SHOT;
            }
        }
        pkt = ((void*)(long)skb->data);
        ebpf_packetEnd = ((void*)(long)skb->data_end);
        ebpf_packetOffsetInBits = 0;

    }
    if (ostd.clone) {
        do_packet_clones(skb, &clone_session_tbl, ostd.clone_session_id, CLONE_E2E, 3);
    }

    if (ostd.drop) {
        return TC_ACT_SHOT;
    }

    if (istd.egress_port == P4C_PSA_PORT_RECIRCULATE) {
        meta->packet_path = RECIRCULATE;
        return bpf_redirect(PSA_PORT_RECIRCULATE, BPF_F_INGRESS);
    }


    return TC_ACT_OK;
}
char _license[] SEC("license") = "GPL";
